{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyTest Streaming","text":"<p>pytest-streaming is a PyTest plugin designed to simplify and automate the setup and teardown of streaming infrastructure for tests. It provides seamless integration for Google Pub/Sub, Apache Pulsar, Apache Kafka [WIP], and Nats [WIP] allowing you to create topics and subscriptions on demand, either globally or per test, using configuration or markers.</p> <p> </p>"},{"location":"#concept","title":"Concept","text":"<p>pytest-streaming enables efficient and reproducible testing of streaming applications by managing the lifecycle of topics and subscriptions. It supports both global and per-test resource management, making it suitable for local development and CI/CD pipelines. The plugin leverages PyTest's configuration system and marker mechanism to provide flexible control over streaming resources.</p> <p>Key features:</p> <ul> <li>Automatic creation and cleanup of topics and subscriptions for streaming technologies</li> <li>Global configuration via <code>pytest.ini</code> or per-test control via markers</li> <li>Support for local emulators and containerized environments</li> <li>Class-based, type-hinted, and fixture-driven test patterns</li> </ul> <p>The general flow for all created resources includes bootstrapping a net-new (clean) topic for the test. By default, topics persist after the test for any validation/metrics collection needed. This however can be configured to auto delete after each run. By default, all topics are deleted and re-created on start of the test.</p> <p>It's generally recommended to bootstrap global topics for integration tests (to avoid mocking out every dependent test) and utilize scoped topics for unit tests.</p> <p> </p>"},{"location":"#supported","title":"Supported","text":"<ol> <li>Apache Pulsar</li> <li>Google PubSub</li> <li>[Coming soon] Kafka</li> <li>[Coming soon] Nats</li> <li>[Coming soon] Kinesis</li> </ol>"},{"location":"#feedback-and-requests","title":"Feedback and requests","text":"<p>Feedback, feature requests, and bug reports are welcome. Please open an issue or discussion on the GitHub repository.</p> <p> </p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are encouraged. See the contributing guide for details on development, setup, and testing.</p>"},{"location":"releases/","title":"Releases","text":""},{"location":"releases/#automation","title":"Automation","text":"<p>This project uses semantic-release to automate versioning and deployment. The release process is triggered automatically when changes are merged into the <code>main</code> branch.</p>"},{"location":"releases/#versioning","title":"Versioning","text":"<p>Semantic versioning is determined by the commit message prefix, examples include</p> <ul> <li><code>feat:</code> for new features (minor version bump)</li> <li><code>fix:</code> for bug fixes (patch version bump)</li> <li><code>chore:</code> for maintenance tasks (no version bump unless files like dependencies are updated)</li> <li><code>major:</code> for breaking changes (major version bump)</li> </ul>"},{"location":"releases/#deployment","title":"Deployment","text":"<p>On every merge to <code>main</code>, the following occurs:</p> <ul> <li>The semantic version is updated based on commit messages.</li> <li>The <code>pyproject.toml</code> version is updated automatically to match the new release version.</li> <li>The package is deployed and released.</li> </ul> <p>No manual intervention is required for versioning or deployment as long as commit messages follow the semantic-release convention.</p>"},{"location":"contributing/contributing/","title":"Contributions","text":"<p>Contributions to <code>pytest-streaming</code> are encouraged and welcome. Whether you want to report a bug, request a feature, improve the documentation, or submit a code change, your input is valued.</p>"},{"location":"contributing/setup/","title":"Setting up for local development","text":"<p>This guide describes how to set up your environment for contributing to <code>pytest-streaming</code>.</p>"},{"location":"contributing/setup/#prerequisites","title":"Prerequisites","text":"<ol> <li>Install Docker to run local emulators and dependencies.</li> <li>Ensure you have Just installed for running project tasks.</li> <li>Make sure you have Python 3.11+ installed and available in your PATH.</li> </ol>"},{"location":"contributing/setup/#running-the-setup-script","title":"Running the setup script","text":"<p>Run the setup script to install Python dependencies and prepare your environment.</p> <pre><code>sh setup.sh\n</code></pre> <p>This will install the latest Python version and set up any additional tooling needed for development</p> <ol> <li>Just</li> <li>UV (python dependency management)</li> <li>Python</li> <li>Yamlfmt</li> </ol>"},{"location":"contributing/setup/#running-the-starter-just-commands","title":"Running the starter just commands","text":"<p>The project uses a <code>justfile</code> to simplify common development tasks. To set up the project, run:</p> <pre><code>just setup\n</code></pre> <p>This will install dependencies and perform any other initial project configuration.</p>"},{"location":"contributing/setup/#starting-docker","title":"Starting docker","text":"<p>To start the required Docker containers (such as Pub/Sub emulator and Pulsar), run:</p> <pre><code>just compose\n</code></pre> <p>This will launch all services defined in the <code>docker-compose.yml</code> file. Wait a few seconds for the containers to become healthy before running tests.</p>"},{"location":"contributing/setup/#validating-setup","title":"Validating setup","text":"<p>To verify your environment is ready, run the following command to check formatting, linting, and run all tests:</p> <pre><code>just check\n</code></pre> <p>All tests, formatting, and linting should pass before you begin development or submit a pull request.</p>"},{"location":"contributing/setup/#running-the-documentation-site","title":"Running the documentation site","text":"<pre><code>just docs\n</code></pre>"},{"location":"contributing/stack/","title":"Tech Stack","text":"<ul> <li>Python: Main programming language for the plugin and tests.</li> <li>pytest: Test runner and framework for all automated tests.</li> <li>uv: Fast Python package installer and virtual environment manager.</li> <li>just: Task runner for common development and CI commands.</li> <li>GitHub Actions: CI/CD automation for testing, linting, and releases.</li> <li>mise: Tool version manager for Python and other tools.</li> <li>semantic-release: Automated versioning and changelog generation based on commit messages.</li> <li>ruff: Linter and code formatter for Python code.</li> <li>mypy: Static type checker for Python.</li> <li>coverage: Code coverage measurement for tests.</li> <li>yamlfmt: Formatter for YAML files.</li> <li>mdformat: Formatter for Markdown files.</li> <li>renovate: Dependency update automation for the repository.</li> <li>docker: Containerization for local emulators and test environments.</li> <li>mkdocs: Static site generator for project documentation.</li> </ul>"},{"location":"contributing/testing/","title":"Testing","text":"<p>All code must maintain 100% test coverage. This ensures that every line of code is exercised by the test suite and helps prevent regressions.</p>"},{"location":"contributing/testing/#validating-changes","title":"Validating Changes","text":"<p>To validate your changes, run:</p> <pre><code>just check\n</code></pre> <p>This command runs linting, formatting, and the full test suite. All checks must pass before submitting a pull request.</p>"},{"location":"contributing/testing/#focus","title":"Focus","text":"<p>Tests should be high quality and cover both unit-testable code and live integrations. This means you should:</p> <ul> <li>Write isolated unit tests for logic that can be tested independently.</li> <li>Ensure integration tests run against real Pub/Sub and Pulsar emulators to verify actual resource creation and cleanup.</li> </ul> <p>Both types of tests are required to ensure correctness and reliability of the plugin in real-world scenarios.</p>"},{"location":"contributing/testing/#continuous-integration","title":"Continuous Integration","text":"<p>All checks, including linting, formatting, and the full test suite, are automatically run and validated by GitHub Actions when a pull request is opened. This ensures that every contribution meets the project's quality standards before it is merged.</p>"},{"location":"specification/pubsub/","title":"Pubsub","text":""},{"location":"specification/pubsub/#markers","title":"Markers","text":""},{"location":"specification/pubsub/#pytest_streaming.pubsub.markers.PubsubMarker","title":"<code>pytest_streaming.pubsub.markers.PubsubMarker</code>","text":"<p>               Bases: <code>BaseMarker</code></p> <p>Primary pubsub marker for working with Pub/Sub topics.</p> <p>This marker allows you to create and delete Pub/Sub topics for testing purposes. It is used to set up the environment for tests that require Pub/Sub topics. By default, the topics are CREATE_OR_REPLACED, meaning that if they already exist, they will be replaced.</p> <p>Attributes:</p> Name Type Description <code>-</code> <code>topics (list[str]</code> <p>A list of Pub/Sub topic names to create. (default: None)</p> <code>-</code> <code>delete_after (bool</code> <p>If True, the topics will be deleted after the test. (default: False)</p> <code>-</code> <code>project_id (str</code> <p>The GCP project ID where the topics will be created. (default: None)</p> Required Parameters <ul> <li>topics (list[str]): A list of Pub/Sub topic names to create. (default: None)</li> </ul> Optional Parameters <ul> <li>delete_after (bool): If True, the topics will be deleted after the test. (default: False)</li> <li>project_id (str): The GCP project ID where the topics will be created. (default: None)</li> </ul> Example <pre><code>@pytest.mark.pubsub(topics=[\"topic1\", \"topic2\"], delete_after=True, project_id=\"my-project-id\")\ndef test_pubsub_topics(request, pytestconfig):\n    # Your test code here\n    pass\n</code></pre> Source code in <code>pytest_streaming/pubsub/markers.py</code> <pre><code>class PubsubMarker(BaseMarker):\n    \"\"\"Primary pubsub marker for working with Pub/Sub topics.\n\n    This marker allows you to create and delete Pub/Sub topics for testing purposes.\n    It is used to set up the environment for tests that require Pub/Sub topics.\n    By default, the topics are CREATE_OR_REPLACED, meaning that if they already exist, they will be replaced.\n\n    Attributes:\n        - topics (list[str]): A list of Pub/Sub topic names to create. (default: None)\n        - delete_after (bool): If True, the topics will be deleted after the test. (default: False)\n        - project_id (str): The GCP project ID where the topics will be created. (default: None)\n\n    Required Parameters:\n        - topics (list[str]): A list of Pub/Sub topic names to create. (default: None)\n\n    Optional Parameters:\n        - delete_after (bool): If True, the topics will be deleted after the test. (default: False)\n        - project_id (str): The GCP project ID where the topics will be created. (default: None)\n\n    Example:\n        ```python\n        @pytest.mark.pubsub(topics=[\"topic1\", \"topic2\"], delete_after=True, project_id=\"my-project-id\")\n        def test_pubsub_topics(request, pytestconfig):\n            # Your test code here\n            pass\n        ```\n    \"\"\"\n\n    marker_name: str = \"pubsub\"\n    marker_description: str = \"Create specified Pub/Sub topics automatically for the test.\"\n    marker_params: list[str] = [param.value for param in PubsubMarkerParams]\n\n    # Default values for the marker parameters\n    _topics: None = None\n    _project_id: None = None\n    _delete_after: bool = False\n\n    @property\n    def topics(self) -&gt; list[str]:\n        if not self.marker:\n            raise ValueError(\"Marker (pubsub) is not set\")  # pragma: no cover\n\n        topics = self.marker.kwargs.get(PubsubMarkerParams.TOPICS.root(), self._topics)\n        if not topics or not isinstance(topics, list) or not all(isinstance(topic, str) for topic in topics):\n            raise ValueError(\"No topics specified or invalid specification (list[str]) for the pubsub marker\")\n        return cast(list[str], topics)\n\n    @property\n    def delete_after(self) -&gt; bool:\n        if not self.marker:\n            raise ValueError(\"Marker (pubsub) is not set\")  # pragma: no cover\n        return self.marker.kwargs.get(PubsubMarkerParams.DELETE_AFTER.root(), self._delete_after)\n\n    @property\n    def project_id(self) -&gt; str:\n        if not self.marker:\n            raise ValueError(\"Marker (pubsub) is not set\")  # pragma: no cover\n\n        override_project_id = self.marker.kwargs.get(PubsubMarkerParams.PROJECT_ID.root(), self._project_id)\n        project_id = override_project_id or self.config.getini(Configuration.PUBSUB_PROJECT_ID)\n        if not isinstance(project_id, str):\n            raise ValueError(\"Invalid specification for project_id (str)\")  # pragma: no cover\n        return project_id\n\n    @contextmanager\n    def impl(self) -&gt; Generator[None, None, None]:\n        if not self.marker:\n            yield\n            return\n\n        safety = self.config.getini(Configuration.PUBSUB_EMULATOR_ENABLED)\n        publisher = GCPPublisher()\n        publisher.setup_testing_topics(self.project_id, self.topics, safety=safety)\n\n        yield\n\n        if self.delete_after:\n            publisher.delete_testing_topics(self.project_id, self.topics, safety=safety)\n</code></pre>"},{"location":"specification/pulsar/","title":"Pulsar","text":""},{"location":"specification/pulsar/#fixtures","title":"Fixtures","text":""},{"location":"specification/pulsar/#pytest_streaming.pulsar.fixtures","title":"<code>pytest_streaming.pulsar.fixtures</code>","text":"<p>Functions:</p> Name Description <code>streaming_pulsar_marker</code> <p>Usable PulsarMarker object</p> <code>streaming_pulsar_client</code> <p>Raw pulsar client using the service url configured for the given test.</p> <code>streaming_pulsar_consumer</code> <p>Raw pulsar consumer using the topics configured for the given test. Yields a unique subscription name each time.</p> <code>streaming_pulsar_producers</code> <p>Raw pulsar producer using the topics configured for the given test.</p>"},{"location":"specification/pulsar/#pytest_streaming.pulsar.fixtures.streaming_pulsar_marker","title":"<code>streaming_pulsar_marker(request, pytestconfig)</code>","text":"<p>Usable PulsarMarker object</p> <p>Yields the base pulsar marker object that gives you access to the designated configurations for the individual test. See PulsarMarker specification.</p> Example <pre><code>    from streaming.pulsar.markers import PulsarMarker\n\n    @pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\n    def test_pulsar_topics(streaming_pulsar_marker: PulsarMarker):\n        assert PulsarMarker.topics == [\"topic-a\", \"topic-b\"]\n</code></pre> <p>Returns:</p> Name Type Description <code>PulsarMarker</code> <code>PulsarMarker</code> <p>object with all of the defined user configurations</p> Source code in <code>pytest_streaming/pulsar/fixtures.py</code> <pre><code>@pytest.fixture\ndef streaming_pulsar_marker(request: FixtureRequest, pytestconfig: Config) -&gt; PulsarMarker:\n    \"\"\"Usable PulsarMarker object\n\n    Yields the base pulsar marker object that gives you access to the designated\n    configurations for the individual test. See PulsarMarker specification.\n\n    Example:\n        ```python\n            from streaming.pulsar.markers import PulsarMarker\n\n            @pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\n            def test_pulsar_topics(streaming_pulsar_marker: PulsarMarker):\n                assert PulsarMarker.topics == [\"topic-a\", \"topic-b\"]\n        ```\n\n    Returns:\n        PulsarMarker: object with all of the defined user configurations\n\n    \"\"\"\n    return PulsarMarker(config=pytestconfig, request=request)\n</code></pre>"},{"location":"specification/pulsar/#pytest_streaming.pulsar.fixtures.streaming_pulsar_client","title":"<code>streaming_pulsar_client(streaming_pulsar_marker)</code>","text":"<p>Raw pulsar client using the service url configured for the given test.</p> <p>Does all of the necessary cleanup for you after the test concludes.</p> Example <pre><code>    from pulsar import Client\n\n    @pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\n    def test_pulsar_topics(streaming_pulsar_client: Client):\n        assert isinstance(streaming_pulsar_client, Client)\n</code></pre> <p>Returns:</p> Type Description <code>Generator[Client, None]</code> <p>pulsar.Client: raw pulsar client from the base pulsar library</p> Source code in <code>pytest_streaming/pulsar/fixtures.py</code> <pre><code>@pytest.fixture\ndef streaming_pulsar_client(streaming_pulsar_marker: PulsarMarker) -&gt; Generator[Client, None]:\n    \"\"\"Raw pulsar client using the service url configured for the given test.\n\n    Does all of the necessary cleanup for you after the test concludes.\n\n    Example:\n        ```python\n            from pulsar import Client\n\n            @pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\n            def test_pulsar_topics(streaming_pulsar_client: Client):\n                assert isinstance(streaming_pulsar_client, Client)\n        ```\n\n    Returns:\n        pulsar.Client: raw pulsar client from the base pulsar library\n    \"\"\"\n    client = Client(service_url=streaming_pulsar_marker.service_url)\n    try:\n        yield client\n    finally:\n        client.close()\n        del client\n</code></pre>"},{"location":"specification/pulsar/#pytest_streaming.pulsar.fixtures.streaming_pulsar_consumer","title":"<code>streaming_pulsar_consumer(streaming_pulsar_client, streaming_pulsar_marker)</code>","text":"<p>Raw pulsar consumer using the topics configured for the given test. Yields a unique subscription name each time.</p> <p>Does all of the necessary cleanup for you after the test concludes.</p> Example <pre><code>    from pulsar import Consumer\n\n    @pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\n    def test_pulsar_topics(streaming_pulsar_consumer: Consumer):\n        print(streaming_pulsar_consumer.subscription_name)\n        msg = streaming_pulsar_consumer.receive()\n</code></pre> <p>Returns:</p> Type Description <code>Generator[Consumer, None]</code> <p>pulsar.Consumer: raw pulsar consumer from the base pulsar library</p> Source code in <code>pytest_streaming/pulsar/fixtures.py</code> <pre><code>@pytest.fixture\ndef streaming_pulsar_consumer(\n    streaming_pulsar_client: Client, streaming_pulsar_marker: PulsarMarker\n) -&gt; Generator[Consumer, None]:\n    \"\"\"Raw pulsar consumer using the topics configured for the given test. Yields a unique subscription name each time.\n\n    Does all of the necessary cleanup for you after the test concludes.\n\n    Example:\n        ```python\n            from pulsar import Consumer\n\n            @pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\n            def test_pulsar_topics(streaming_pulsar_consumer: Consumer):\n                print(streaming_pulsar_consumer.subscription_name)\n                msg = streaming_pulsar_consumer.receive()\n        ```\n\n    Returns:\n        pulsar.Consumer: raw pulsar consumer from the base pulsar library\n    \"\"\"\n    consumer = streaming_pulsar_client.subscribe(\n        topic=streaming_pulsar_marker.topics, subscription_name=str(uuid.uuid4())\n    )\n    try:\n        yield consumer\n    finally:\n        consumer.close()\n        del consumer\n</code></pre>"},{"location":"specification/pulsar/#pytest_streaming.pulsar.fixtures.streaming_pulsar_producers","title":"<code>streaming_pulsar_producers(streaming_pulsar_client, streaming_pulsar_marker)</code>","text":"<p>Raw pulsar producer using the topics configured for the given test.</p> <p>Does all of the necessary cleanup for you after the test concludes.</p> Example <pre><code>    from pulsar import Producer\n\n    @pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\n    def test_pulsar_topics(streaming_pulsar_producers: dict[str, Producer]):\n        producer_a = streaming_pulsar_producers[\"topic-a\"]\n        producer_b = streaming_pulsar_producers[\"topic-b\"]\n        producer_a.send(...)\n        producer_b.send(...)\n</code></pre> <p>Returns:</p> Type Description <code>Generator[dict[str, Producer], None]</code> <p>dict[topic.name, pulsar.Producer]: raw pulsar producers from the base pulsar library</p> Source code in <code>pytest_streaming/pulsar/fixtures.py</code> <pre><code>@pytest.fixture\ndef streaming_pulsar_producers(\n    streaming_pulsar_client: Client, streaming_pulsar_marker: PulsarMarker\n) -&gt; Generator[dict[str, Producer], None]:\n    \"\"\"Raw pulsar producer using the topics configured for the given test.\n\n    Does all of the necessary cleanup for you after the test concludes.\n\n    Example:\n        ```python\n            from pulsar import Producer\n\n            @pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\n            def test_pulsar_topics(streaming_pulsar_producers: dict[str, Producer]):\n                producer_a = streaming_pulsar_producers[\"topic-a\"]\n                producer_b = streaming_pulsar_producers[\"topic-b\"]\n                producer_a.send(...)\n                producer_b.send(...)\n        ```\n\n    Returns:\n        dict[topic.name, pulsar.Producer]: raw pulsar producers from the base pulsar library\n    \"\"\"\n\n    # TODO: update to property w/ support for dynamic tenant/namespace\n    topic_objs = [\n        TopicMeta(\n            topic_name=topic, tenant=streaming_pulsar_marker._tenant, namespace=streaming_pulsar_marker._namespace\n        )\n        for topic in streaming_pulsar_marker.topics\n    ]\n\n    producers = {topic_obj.short: streaming_pulsar_client.create_producer(topic_obj.long) for topic_obj in topic_objs}\n\n    try:\n        yield producers\n    finally:\n        for _, producer in producers.items():\n            producer.close()\n            del producer\n</code></pre>"},{"location":"specification/pulsar/#markers","title":"Markers","text":""},{"location":"specification/pulsar/#pytest_streaming.pulsar.markers.PulsarMarker","title":"<code>pytest_streaming.pulsar.markers.PulsarMarker</code>","text":"<p>               Bases: <code>BaseMarker</code></p> <p>Primary pulsar marker for working with Pulsar topics.</p> <p>This marker allows you to create and delete Pulsar topics for testing purposes. It ensures the specified tenant and namespace exist before creating topics. By default, topics are recreated if they already exist.</p> <p>Attributes:</p> Name Type Description <code>-</code> <code>marker_name (str</code> <p>name of the marker</p> <code>-</code> <code>marker_description (str</code> <p>description of the marker</p> <code>-</code> <code>topics (list[str]</code> <p>A list of Pulsar topic names to create.</p> <code>-</code> <code>delete_after (bool</code> <p>If True, the topics will be deleted after the test. (default: False)</p> <code>-</code> <code>service_url (str</code> <p>The Pulsar service URL. (default: from pytest.ini or Defaults.PULSAR_SERVICE_URL)</p> <code>-</code> <code>admin_url (str</code> <p>The pulsar admin URL (default: from pytest.ini or Defaults.PULSAR_ADMIN_URL)</p> Required Parameters <ul> <li>topics (list[str])</li> </ul> Optional Parameters <ul> <li>delete_after (bool)</li> <li>service_url (str)</li> <li>admin_url (str)</li> </ul> Example <pre><code>@pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\ndef test_pulsar_topics():\n    # Your test code here\n    pass\n</code></pre> Source code in <code>pytest_streaming/pulsar/markers.py</code> <pre><code>class PulsarMarker(BaseMarker):\n    \"\"\"Primary pulsar marker for working with Pulsar topics.\n\n    This marker allows you to create and delete Pulsar topics for testing purposes.\n    It ensures the specified tenant and namespace exist before creating topics.\n    By default, topics are recreated if they already exist.\n\n    Attributes:\n        - marker_name (str): name of the marker\n        - marker_description (str): description of the marker\n        - topics (list[str]): A list of Pulsar topic names to create.\n        - delete_after (bool): If True, the topics will be deleted after the test. (default: False)\n        - service_url (str): The Pulsar service URL. (default: from pytest.ini or Defaults.PULSAR_SERVICE_URL)\n        - admin_url (str): The pulsar admin URL (default: from pytest.ini or Defaults.PULSAR_ADMIN_URL)\n\n    Required Parameters:\n        - topics (list[str])\n\n    Optional Parameters:\n        - delete_after (bool)\n        - service_url (str)\n        - admin_url (str)\n\n    Example:\n        ```python\n        @pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\n        def test_pulsar_topics():\n            # Your test code here\n            pass\n        ```\n    \"\"\"\n\n    marker_name: str = \"pulsar\"\n    marker_description: str = \"Create specified Pulsar topics automatically for the test.\"\n    marker_params: list[str] = [param.value for param in PulsarMarkerParams]\n\n    # Default values for the marker parameters\n    _tenant: str = Defaults.PULSAR_TENANT.value\n    _namespace: str = Defaults.PULSAR_NAMESPACE.value\n\n    @property\n    def topics(self) -&gt; list[str]:\n        if not self.marker:\n            raise ValueError(\"Marker (pulsar) is not set\")  # pragma: no cover\n\n        topics = self.marker.kwargs.get(PulsarMarkerParams.TOPICS.root())\n        if not topics or not isinstance(topics, list) or not all(isinstance(topic, str) for topic in topics):\n            raise ValueError(\"No topics specified or invalid specification (list[str]) for the pulsar marker\")\n        return cast(list[str], topics)\n\n    @property\n    def delete_after(self) -&gt; bool:\n        if not self.marker:\n            raise ValueError(\"Marker (pulsar) is not set\")  # pragma: no cover\n\n        delete_after = self.marker.kwargs.get(PulsarMarkerParams.DELETE_AFTER.root(), Defaults.PULSAR_AUTO_DELETE.value)\n        if not isinstance(delete_after, bool):\n            raise ValueError(\"Invalid specification for delete_after (bool)\")  # pragma: no cover\n        return delete_after\n\n    @property\n    def service_url(self) -&gt; str:\n        if not self.marker:\n            raise ValueError(\"Marker (pulsar) is not set\")  # pragma: no cover\n\n        override_url = self.marker.kwargs.get(PulsarMarkerParams.SERVICE_URL.root())\n        service_url = override_url or self.config.getini(Configuration.PULSAR_SERVICE_URL)\n        if not isinstance(service_url, str):\n            raise ValueError(\"Invalid specification for service_url (str)\")  # pragma: no cover\n        return service_url\n\n    @property\n    def admin_url(self) -&gt; str:\n        if not self.marker:\n            raise ValueError(\"Marker (pulsar) is not set\")  # pragma: no cover\n\n        override_url = self.marker.kwargs.get(PulsarMarkerParams.ADMIN_URL.root())\n        admin_url = override_url or self.config.getini(Configuration.PULSAR_ADMIN_URL)\n        if not isinstance(admin_url, str):\n            raise ValueError(\"Invalid specification for admin_url (str)\")  # pragma: no cover\n        return admin_url\n\n    @property\n    def _topic_meta(self) -&gt; list[TopicMeta]:\n        return [TopicMeta(topic_name=topic, tenant=self._tenant, namespace=self._namespace) for topic in self.topics]\n\n    @cached_property\n    def _pulsar_client(self) -&gt; PulsarClientWrapper:\n        return PulsarClientWrapper(service_url=self.service_url, admin_url=self.admin_url)\n\n    @contextmanager\n    def impl(self) -&gt; Generator[None, None, None]:\n        if not self.marker:\n            yield\n            return\n\n        try:\n            self._pulsar_client.setup_testing_topics(topics=self._topic_meta)\n\n            yield\n\n            if self.delete_after:\n                self._pulsar_client.delete_testing_topics(topics=self._topic_meta)\n        finally:\n            self._pulsar_client.close()\n</code></pre>"},{"location":"usage/getting_started/","title":"Getting started quickly","text":"<p>For a quick start, you can follow these steps</p>"},{"location":"usage/getting_started/#install-pytest-streaming","title":"Install pytest-streaming","text":"<pre><code>pip install pytest-streaming\n</code></pre>"},{"location":"usage/getting_started/#utilize-the-decorator-for-the-streaming-technology-of-your-choice","title":"Utilize the decorator for the streaming technology of your choice","text":"<p>Detailed specifications and usage can be found here</p> <ul> <li>Pulsar</li> <li>Pubsub</li> </ul> <p> </p>"},{"location":"usage/getting_started/#base-pulsar-example","title":"Base Pulsar example","text":""},{"location":"usage/getting_started/#setting-up-a-local-environment-pulsar","title":"Setting up a local environment - Pulsar","text":"<p>If you're using docker compose, adding this for pulsar will get you up and running end to end (<code>docker-compose.yml</code>)</p> <pre><code>services:\n  pulsar:\n    image: apachepulsar/pulsar:latest\n    container_name: pulsar\n    ports: ['6650:6650', '8080:8080']\n    environment:\n    - PULSAR_STANDALONE_ENABLED=true\n    - allowAutoTopicCreation=true\n    command: [bin/pulsar, standalone]\n</code></pre> <p>Now you can run: <code>docker compose up -d</code> to have pulsar locally bootstrapped.</p> <p> </p>"},{"location":"usage/getting_started/#using-the-pulsar-marker","title":"Using the pulsar marker","text":"<p>You can simply create test specific topics on any unit or integration test by leveraging the associated marker, for example</p> <pre><code>class TestPulsarProducer:\n    @pytest.mark.pulsar(topics=[\"test-topic1\", \"test-topic2\"])\n    def test_pubsub_marker_topic_creation_base(self) -&gt; None:\n        # these pulsar topics are now available and completely clean\n        # note these live by default in `public/default` namespace\n        ...\n</code></pre> <p>Everything will be created and cleaned up for you by default on every test run. Each decorator has a suite of customizable features. Read the documentation to see other parameters you can use and how you can create topics for global use (integration tests).</p> <p> </p>"},{"location":"usage/getting_started/#adding-to-your-cicd","title":"Adding to your CI/CD","text":"<p>Running this in CI/CD is as simple as ensuring pulsar (or other streaming choice) is running in the network. For the example above, adding this step to your GitHub action will yield all the setup required</p> <pre><code>- name: run docker-compose\n    run: |\n    docker compose up -d\n    sleep 5s\n</code></pre> <p> </p>"},{"location":"usage/pubsub/","title":"PubSub Usage","text":"<p>This section describes how to use the Pub/Sub integration in <code>pytest-streaming</code> for managing topics in your tests. The plugin supports both global and per-test topic management using either <code>pytest.ini</code> configuration or test markers.</p> <p>View the specification for verbose details on all usable interfaces of this library</p> <p> </p>"},{"location":"usage/pubsub/#pubsub-marker-usage","title":"PubSub Marker Usage","text":"<p>The <code>@pytest.mark.pubsub</code> marker allows you to create and optionally delete Pub/Sub topics for the duration of a test. This is useful for isolating test resources and ensuring a clean environment.</p>"},{"location":"usage/pubsub/#marker-parameters","title":"Marker Parameters","text":"<p>The following parameters are supported by the <code>pubsub</code> marker:</p> <ul> <li><code>topics</code> (list[str], required): List of Pub/Sub topic names to create for the test.</li> <li><code>delete_after</code> (bool, optional): If <code>True</code>, topics are deleted after the test. Default is <code>False</code>. Resources are always cleaned up prior to each test run.</li> <li><code>project_id</code> (str, optional): GCP project ID. Defaults to the value in <code>pytest.ini</code> or the plugin default of <code>pytest-streaming</code>.</li> </ul> <p>Examples:</p> <pre><code>import pytest\n\n@pytest.mark.pubsub(topics=[\"test-topic-1\", \"test-topic-2\"])\nclass TestPubsub:\n    def test_topic_creation(self):\n        # Test logic using the created topics\n        pass\n</code></pre> <pre><code>import pytest\n\n@pytest.mark.pubsub(topics=[\"test-topic-1\", \"test-topic-2\"], delete_after=True)\nclass TestPubsub:\n    def test_topic_creation(self):\n        # Test logic using the created topics\n        pass\n</code></pre> <pre><code>import pytest\n\n@pytest.mark.pubsub(topics=[\"test-topic-1\", \"test-topic-2\"], delete_after=True, project_id=\"my-gcp-project\")\nclass TestPubsub:\n    def test_topic_creation(self):\n        # Test logic using the created topics\n        pass\n</code></pre>"},{"location":"usage/pubsub/#pytestini-options-marker-defaults","title":"PyTest.ini Options (Marker Defaults)","text":"<p>You can set default values for marker parameters in your <code>pytest.ini</code> file. These will be used if the marker does not override them.</p> <pre><code>[pytest]\npytest_streaming_pubsub_project_id = pytest-streaming\npytest_streaming_pubsub_emulator_enabled = true\n</code></pre> <p><code>pytest_streaming_pubsub_emulator_enabled</code> is a optional parameter that defaults to True. It is a base safety to ensure you are targeting the pubsub emulator and not a live instance in Google Cloud. You can easily disable this by setting that value to <code>false</code>.</p> <p> </p>"},{"location":"usage/pubsub/#pubsub-global-usage","title":"PubSub Global Usage","text":"<p>You can configure global topics to be created at the start of the test session and optionally deleted at the end. This is useful for integration tests that share topics across multiple tests.</p>"},{"location":"usage/pubsub/#pytestini-options","title":"PyTest.ini Options","text":"<p>Add the following options to your <code>pytest.ini</code> to manage global topics. These must use the exact keys as defined by the plugin:</p> <ul> <li><code>pytest_streaming_pubsub_global_topics</code> (linelist): New-line separated list of topics to create globally.</li> <li><code>pytest_streaming_pubsub_global_delete</code> (bool): If <code>True</code>, global topics are deleted after the session. Default is <code>False</code>.</li> <li><code>pytest_streaming_pubsub_project_id</code> (str): GCP project ID. Default is <code>pytest-streaming</code>.</li> <li><code>pytest_streaming_pubsub_emulator_enabled</code> (bool): Ensures the Pub/Sub emulator is being used. Default is <code>true</code>.</li> </ul> <p>Example:</p> <pre><code>[pytest]\npytest_streaming_pubsub_global_topics = \n    topic1 \n    topic2\n\npytest_streaming_pubsub_global_delete = true\npytest_streaming_pubsub_project_id = pytest-streaming\npytest_streaming_pubsub_emulator_enabled = true\n</code></pre> <p>With these settings, the specified topics will be created at session start and deleted at session end if <code>pytest_streaming_pubsub_global_delete</code> is enabled.</p> <p>The project id will be the new default for all markers used within the test suite, you can still override this as needed per test via the marker. The global delete will only affect the global topics stated above.</p> <p> </p>"},{"location":"usage/pubsub/#setting-up-pubsub","title":"Setting up Pub/Sub","text":""},{"location":"usage/pubsub/#setting-up-pubsub-locally","title":"Setting up Pub/Sub locally","text":"<p>If you have Docker installed, you can leverage a docker compose file to bootstrap the resources needed to run this locally and in CI/CD.</p> <p>Create a file called <code>docker-compose.yml</code> and paste the following within it</p> <pre><code>services:\n  pubsub-emulator:\n    image: google/cloud-sdk:latest\n    command: gcloud beta emulators pubsub start --project=pytest-streaming --host-port=0.0.0.0:8432\n    ports: ['8432:8432']\n    environment:\n      PUBSUB_PROJECT_ID: pytest-streaming\n      PUBSUB_EMULATOR_HOST: localhost:8432\n</code></pre>"},{"location":"usage/pubsub/#setting-up-pubsub-in-cicd","title":"Setting up Pub/Sub in CI/CD","text":"<p>The example provided is for GitHub actions, but if you are using other platforms (Jenkins, for example) the setup is mostly the same. Simply need to enable and start the pubsub emulator in your network.</p> <p>Doing this with a GitHub action is as simple as leveraging the <code>docker-compose.yml</code> file setup in the previous step.</p> <pre><code>name: test check\non:\n  push:\n    branches: [main]\n\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout\n\n    - name: run docker-compose\n      run: |\n        docker compose up -d\n        sleep 10s\n\n    - name: run test\n      run: |-\n        # your test command\n</code></pre>"},{"location":"usage/pulsar/fixtures/","title":"Available Pulsar Fixtures","text":"<p>The plugin provides several fixtures to streamline the use of Apache Pulsar in your tests. These fixtures handle setup and teardown automatically, ensuring resources are managed efficiently and tests remain isolated.</p>"},{"location":"usage/pulsar/fixtures/#streaming_pulsar_marker","title":"streaming_pulsar_marker","text":"<p>Yields a <code>PulsarMarker</code> object, which encapsulates all marker-based configuration for the current test. It provides access to the topics, service URL, admin URL, and other marker parameters as defined either in the test marker or in the global pytest configuration.</p>"},{"location":"usage/pulsar/fixtures/#pulsar-marker-parameters","title":"Pulsar Marker Parameters","text":"<ul> <li><code>marker_name</code> (str): Name of the marker.</li> <li><code>marker_description</code> (str): Description of the marker.</li> <li><code>topics</code> (list[str]): A list of Pulsar topic names created.</li> <li><code>delete_after</code> (bool): Whether or not topics are deleted after this test concludes.</li> <li><code>service_url</code> (str): The Pulsar service URL.</li> <li><code>admin_url</code> (str): The Pulsar admin URL.</li> </ul> <p>Usage Example:</p> <pre><code>from streaming.pulsar.markers import PulsarMarker\n\n@pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\ndef test_pulsar_topics(streaming_pulsar_marker: PulsarMarker):\n    assert streaming_pulsar_marker.topics == [\"topic-a\", \"topic-b\"]\n</code></pre>"},{"location":"usage/pulsar/fixtures/#streaming_pulsar_client","title":"streaming_pulsar_client","text":"<p>Yields a raw Pulsar client, configured using the service URL from the current marker or global configuration. The client is automatically cleaned up after the test completes.</p> <p>Usage Example:</p> <pre><code>from pulsar import Client\n\n@pytest.mark.pulsar(topics=[\"topic-a\"])\ndef test_pulsar_client(streaming_pulsar_client: Client):\n    assert isinstance(streaming_pulsar_client, Client)\n</code></pre>"},{"location":"usage/pulsar/fixtures/#streaming_pulsar_consumer","title":"streaming_pulsar_consumer","text":"<p>Yields a Pulsar consumer, subscribed to the topics specified in the marker. Each consumer is given a unique subscription name for the test. Cleanup is handled automatically.</p> <p>Type: <code>pulsar.Consumer</code></p> <p>Usage Example:</p> <pre><code>from pulsar import Consumer\n\n@pytest.mark.pulsar(topics=[\"topic-a\"])\ndef test_pulsar_consumer(streaming_pulsar_consumer: Consumer):\n    print(streaming_pulsar_consumer.subscription_name)\n    msg = streaming_pulsar_consumer.receive()\n</code></pre>"},{"location":"usage/pulsar/fixtures/#streaming_pulsar_producers","title":"streaming_pulsar_producers","text":"<p>Yields a dictionary mapping topic names to Pulsar producer instances, one for each topic specified in the marker. All producers are cleaned up after the test.</p> <p>Type: <code>dict[str, pulsar.Producer]</code></p> <p>Usage Example:</p> <pre><code>from pulsar import Producer\n\n@pytest.mark.pulsar(topics=[\"topic-a\", \"topic-b\"])\ndef test_pulsar_producers(streaming_pulsar_producers: dict[str, Producer]):\n    producer_a = streaming_pulsar_producers[\"topic-a\"]\n    producer_b = streaming_pulsar_producers[\"topic-b\"]\n    producer_a.send(...)\n    producer_b.send(...)\n</code></pre> <p>These fixtures can be used independently or together, depending on the needs of your test. They abstract away the boilerplate of Pulsar client and resource management, allowing you to focus on your test logic.</p>"},{"location":"usage/pulsar/fixtures/#full-example","title":"Full example","text":"<pre><code>@pytest.mark.pulsar(topics=[PulsarTopicName.FIXTURE_MARKER_TOPIC_TWO])\ndef test_pulsar_producers_fixture(\n    self, streaming_pulsar_producers: dict[str, Producer], streaming_pulsar_consumer: Consumer\n) -&gt; None:\n    payload = b\"test\"\n    producer = streaming_pulsar_producers[PulsarTopicName.FIXTURE_MARKER_TOPIC_TWO]\n    producer.send(payload)\n\n    msg = streaming_pulsar_consumer.receive()\n    assert isinstance(producer, Producer)\n    assert len(streaming_pulsar_producers) == 1\n    assert set(streaming_pulsar_producers) == {PulsarTopicName.FIXTURE_MARKER_TOPIC_TWO}\n    assert msg.data() == payload\n</code></pre> <p>If you're using these as objects in your codebase, you can simply mock them in-place:</p> <pre><code>@pytest.mark.pulsar(topics=[PulsarTopicName.FIXTURE_MARKER_TOPIC_TWO])\ndef test_pulsar_producers_fixture(\n    self, \n    streaming_pulsar_producers: dict[str, Producer], \n    streaming_pulsar_consumer: Consumer,\n    your_client: MyCustomProducer,\n    mocker: MockerFixture # from pytest\n) -&gt; None:\n    mocker.patch.object(your_client, \"producer\", new=pulsar_producer)\n</code></pre>"},{"location":"usage/pulsar/global/","title":"Pulsar Global Usage","text":"<p>You can configure global topics to be created at the start of the test session and optionally deleted at the end. This is useful for integration tests that share topics across multiple tests.</p>"},{"location":"usage/pulsar/global/#pytestini-options","title":"PyTest.ini Options","text":"<p>Add the following options to your <code>pytest.ini</code> to manage global topics. These must use the exact keys as defined by the plugin:</p> <ul> <li><code>pytest_streaming_pulsar_global_topics</code> (linelist): New-line separated list of topics to create globally.</li> <li><code>pytest_streaming_pulsar_global_delete</code> (bool): If <code>True</code>, global topics are deleted after the session. Default is <code>False</code>.</li> <li><code>pytest_streaming_pulsar_service_url</code> (str): Pulsar service URL default is <code>pulsar://localhost:6650</code>.</li> <li><code>pytest_streaming_pulsar_admin_url</code> (str): Pulsar admin URL default is <code>http://localhost:8080</code>.</li> </ul> <p>Example:</p> <pre><code>[pytest]\npytest_streaming_pulsar_global_topics = \n    topic1 \n    topic2\n\npytest_streaming_pulsar_global_delete = true\npytest_streaming_pulsar_service_url = pulsar://localhost:6650\npytest_streaming_pulsar_admin_url = http://localhost:8080\n</code></pre> <p>With these settings, the specified topics will be created at session start and deleted at session end if <code>pytest_streaming_pulsar_global_delete</code> is enabled.</p> <p>The service url and admin url will be the new defaults for all markers used within the test suite, you can still override these as needed per test via the marker. The global delete will only affect the global topics stated above.</p>"},{"location":"usage/pulsar/markers/","title":"Pulsar Marker Usage","text":"<p>The <code>@pytest.mark.pulsar</code> marker allows you to create and optionally delete Pulsar topics for the duration of a test. This is useful for isolating test resources and ensuring a clean environment.</p>"},{"location":"usage/pulsar/markers/#marker-parameters","title":"Marker Parameters","text":"<p>The following parameters are supported by the <code>pulsar</code> marker:</p> <ul> <li><code>topics</code> (list[str], required): List of Pulsar topic names to create for the test.</li> <li><code>delete_after</code> (bool, optional): If <code>True</code>, topics are deleted after the test. Default is <code>False</code>. Resources are always cleaned up prior to each test run.</li> <li><code>service_url</code> (str, optional): Pulsar service URL. Defaults to the value in <code>pytest.ini</code> or the plugin default of <code>pulsar://localhost:6650</code></li> <li><code>admin_url</code> (str, optional): Pulsar admin URL. Defaults to the value in <code>pytest.ini</code> or the plugin default of <code>http://localhost:8080</code></li> </ul> <p>Examples:</p> <pre><code>import pytest\n\n@pytest.mark.pulsar(topics=[\"test-topic-1\", \"test-topic-2\"])\nclass TestPulsar:\n    def test_topic_creation(self):\n        # Test logic using the created topics\n        pass\n</code></pre> <pre><code>import pytest\n\n@pytest.mark.pulsar(topics=[\"test-topic-1\", \"test-topic-2\"], delete_after=True)\nclass TestPulsar:\n    def test_topic_creation(self):\n        # Test logic using the created topics\n        pass\n</code></pre> <pre><code>import pytest\n\n@pytest.mark.pulsar(topics=[\"test-topic-1\", \"test-topic-2\"], delete_after=True, service_url=\"pulsar://localhost:1234\")\nclass TestPulsar:\n    def test_topic_creation(self):\n        # Test logic using the created topics\n        pass\n</code></pre>"},{"location":"usage/pulsar/markers/#pytestini-options-marker-defaults","title":"PyTest.ini Options (Marker Defaults)","text":"<p>You can set default values for marker parameters in your <code>pytest.ini</code> file. These will be used if the marker does not override them.</p> <pre><code>[pytest]\npytest_streaming_pulsar_service_url = pulsar://localhost:6650\npytest_streaming_pulsar_admin_url = http://localhost:8080\n</code></pre>"},{"location":"usage/pulsar/setup/","title":"Setting up Pulsar","text":""},{"location":"usage/pulsar/setup/#setting-up-pulsar-locally","title":"Setting up Pulsar locally","text":"<p>If you have Docker installed, you can leverage a docker compose file to bootstrap the resources needed to run this locally and in CI/CD.</p> <p>Create a file called <code>docker-compose.yml</code> and paste the following within it</p> <pre><code>services:\n  pulsar:\n    image: apachepulsar/pulsar:4.0.4\n    container_name: pulsar\n    ports: ['6650:6650', '8080:8080']\n    environment:\n    - PULSAR_STANDALONE_ENABLED=true\n    - allowAutoTopicCreation=true\n    command: [bin/pulsar, standalone]\n</code></pre>"},{"location":"usage/pulsar/setup/#setting-up-pulsar-in-cicd","title":"Setting up Pulsar in CI/CD","text":"<p>The example provided is for GitHub actions, but if you are using other platforms (Jenkins, for example) the setup is mostly the same. Simply need to enable and start the standalone pulsar instance in your network.</p> <p>Doing this with a GitHub action is as simple as leveraging the <code>docker-compose.yml</code> file setup in the previous step.</p> <pre><code>name: test check\non:\n  push:\n    branches: [main]\n\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout\n\n    - name: run docker-compose\n      run: |\n        docker compose up -d\n        sleep 10s\n\n    - name: run test\n      run: |-\n        # your test command\n</code></pre>"},{"location":"usage/pulsar/usage/","title":"Pulsar Usage","text":"<p>This section describes how to use the Pulsar integration in <code>pytest-streaming</code> for managing topics in your tests. The plugin supports both global and per-test topic management using either <code>pytest.ini</code> configuration or test markers. The plugin also includes a suite of fixtures to seamlessly integrate with your testing suite</p> <p>View the specification for verbose details on all usable interfaces of this library</p>"}]}